worker запускается так:

python3 worker.py registration C


где registration - название подсистемы, а C - название воркера (это будут гуиды потом)

клиент запускается так:


python3 client.py registration c

Потом смотреть текстовые файлы, там логи.

Суть работы: у нас есть несколько клиентов, которые посылают задания в пул воркеров. Задания бывают двух видов - запросы и команды.
Запросы могут выполняться в любом порядке по мере поступления, команды должны выполняться строко последовательно для тенантов.
Для этого и запросы и команды увеличивают оперделенные счетчики для тенантов в redis, потом ждут какое-то время и потом читают счетчики.

Proof of work: счетчики для запросов могут не совпадать, счетчики для команд в начале и конце работы должны совпадать,
для последовательных команд одного тенанта счетчики должны каждый раз увеличиваться на 1 без пропусков

Обработка упавших задач:
таймаут воркера 30 секунд. Если по прошествии этого времени задача не является подтвержденно выполненной, задачу подхватывает другой воркер

Можно поиграться с таймаутами и посмотреть, как воркеры будут друг у друга забирать задачу

Механизма проверки доступности воркера пока не нашел.
Хотелось бы что-то типа понга "я еще жив, задачу выполняю" от consumer'а. Может быть стоит спрашивать xpending, это единственный из групповых запросов, который не меняет ничего, кроме idle time

Надо еще с xclaim поэкспериментировать, там и consumername и message_id есть.
Либо для долгоиграющих задач делать xack, но тогда непонятно, как быть, если воркер упал
